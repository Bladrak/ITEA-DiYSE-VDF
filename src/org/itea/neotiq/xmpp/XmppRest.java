package org.itea.neotiq.xmpp;import java.io.IOException;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import org.jivesoftware.smack.packet.IQ;import org.jivesoftware.smack.provider.IQProvider;import org.jivesoftware.smack.provider.ProviderManager;import org.xmlpull.v1.XmlPullParser;import org.xmlpull.v1.XmlPullParserException;public class XmppRest extends IQ {	static {		ProviderManager.getInstance().addIQProvider("query", XmppRest.NAMESPACE, new XmppRest.Provider());        ProviderManager.getInstance().addIQProvider("result", XmppRest.NAMESPACE, new XmppRest.Provider());	}	public static final String NAMESPACE = "urn:xmpp:rest:0";	public enum RestType {    		XMPPREST_UNKNOWN, XMPPREST_QUERY, XMPPREST_RESULT	}	protected RestType type = RestType.XMPPREST_UNKNOWN;	protected String method = null;	protected String resource = null;	protected int status = 0;	protected String message = null;	protected HashMap<String, String> headers = null;	protected String body = null;		private static final String[][] XML_ESCAPE = {		{"\"", "&quot;"}, // " - double-quote		{"&", "&amp;"},   // & - ampersand		{"<", "&lt;"},    // < - less-than		{">", "&gt;"},    // > - greater-than		{"'", "&apos;"},  // XML apostrophe	};		private static final Iterable<Integer> getUnicodeIterable(final String data) {		return new Iterable<Integer>() {					    public Iterator<Integer> iterator() {				return new Iterator<Integer>() {					int nextIndex = 0;								public boolean hasNext() {						return nextIndex < data.length();					}					public Integer next() {						int result = data.codePointAt(nextIndex);						nextIndex += Character.charCount(result);						return result;					}					public void remove() {						throw new UnsupportedOperationException();					}				};			}		};	}		private static final int[] getCodepointsFromString(String data) {		int [] result = new int [data.codePointCount(0, data.length())];		int i = 0;		for(Integer codePoint : getUnicodeIterable(data)) {			result[i] = codePoint;			i++;		}		return result;	}		private static final <T> Map<T, T> mapFromArray(T[][] elements) {		Map<T, T> items = new HashMap<T, T>();		for(T[] item : elements) {			if (item.length == 2) {				items.put(item[0], item[1]);			}		}		return items;	}		private static final <T> Map<T, T> mapFromArrayInverted(T[][] elements) {		Map<T, T> items = new HashMap<T, T>();		for(T[] item : elements) {			if (item.length == 2) {				items.put(item[1], item[0]);			}		}		return items;	}		private static final String translate(String data, Map<String, String> table) {		StringBuilder builder = new StringBuilder(data.length() * 2);		int min, max;		min = Integer.MAX_VALUE;		max = 0;		for(String s : table.keySet()) {			if (s.length() > max)				max = s.length();			if (s.length() < min)				min = s.length();		}		if (min == 0 || max < min) {			throw new IllegalArgumentException();		}		int[] codepoints = getCodepointsFromString(data);		int index = 0;		while (index < codepoints.length) {			int j;			for(j = Math.min(max, codepoints.length - index); j >= min; j--) {				String replacement = table.get(new String(codepoints, index, j));				if (replacement != null) {					builder.append(replacement);					index = index + j;					break;				}			}			if (j < min) {				// We didn't found anything				builder.appendCodePoint(codepoints[index]);				index = index + 1;			}		}		return builder.toString();	}		protected static final String escapeXML(String data) {		Map<String, String> escapes = mapFromArray(XML_ESCAPE);		return translate(data, escapes);	}		protected static final String unescapeXML(String data) {		Map<String, String> escapes = mapFromArrayInverted(XML_ESCAPE);		return translate(data, escapes);	}	public XmppRest() {		headers = new HashMap<String, String>();	}	public void setHeader(String field, String value) {		headers.put(field, value);	}	public void setQuery(String method, String resource) {		this.type = RestType.XMPPREST_QUERY;		this.method = method;		this.resource = resource;	}	public void setResult(int status, String message) {		this.type = RestType.XMPPREST_RESULT;		this.status = status;		this.message = message;	}	public void setBody(String body) {		this.body = body;	}	public RestType getRestType() {		return type;	}	public String getMethod() throws Exception {		if (type != RestType.XMPPREST_QUERY) {			throw new Exception("REST IQ isn't a query");		}		return method;	}	public String getResource() throws Exception {		if (type != RestType.XMPPREST_QUERY) {			throw new Exception("REST IQ isn't a query");		}		return resource;	}	public int getStatus() throws Exception {		if (type != RestType.XMPPREST_RESULT) {			throw new Exception("REST IQ isn't a result");		}		return status;	}	public String getMessage() throws Exception {		if (type != RestType.XMPPREST_RESULT) {			throw new Exception("REST IQ isn't a result");		}		return message;	}	public String getBody() {		return body;	}	public Map<String, String> getHeaders() {		return headers;	}	public static class Provider implements IQProvider {		public Provider() {			super();		}		protected void parseHeaders(XmlPullParser parser, XmppRest iq) throws XmlPullParserException, IOException {			int eventType = parser.next();			while(true) {				if (eventType == XmlPullParser.START_TAG) {					if (parser.getName().equals("header")) {						String field = null;						String value = null;						for(int i = 0; i < parser.getAttributeCount(); i++) {							if (parser.getAttributeName(i).equals("field")) {								field = unescapeXML(parser.getAttributeValue(i));							}							else if (parser.getAttributeName(i).equals("value")) {								value = unescapeXML(parser.getAttributeValue(i));							}						}						if (field != null && value != null) {							iq.setHeader(field, value);						}					}					else {						break;					}				}				else if (eventType == XmlPullParser.END_TAG) {					if (parser.getName().equals("headers")) {						// We have done						break;					}					else if (parser.getName().equals("header")) {						// Do nothing					}					else {						// Unknown : we get out						break;					}				}				eventType = parser.next();			}		}		public IQ parseIQ(XmlPullParser parser) throws Exception {			XmppRest iq = new XmppRest();			boolean done = false;			if (parser.getEventType() == XmlPullParser.START_TAG) {				if (parser.getName().equals("query")) {					String method = null;					String resource = null;					for(int i = 0; i < parser.getAttributeCount(); i++) {						if (parser.getAttributeName(i).equals("method")) {							method = unescapeXML(parser.getAttributeValue(i));						}						else if (parser.getAttributeName(i).equals("resource")) {							resource = unescapeXML(parser.getAttributeValue(i));						}					}					if (method != null && resource != null) {						iq.setQuery(method, resource);					}					else {						throw new Exception("Invalid XMPP-REST query stanza");					}				}				else if (parser.getName().equals("result")) {					int status = 0;					String message = null;					for(int i = 0; i < parser.getAttributeCount(); i++) {						if (parser.getAttributeName(i).equals("status")) {							status = Integer.parseInt(parser.getAttributeValue(i));						}						else if (parser.getAttributeName(i).equals("message")) {							message = unescapeXML(parser.getAttributeValue(i));						}					}					if (message == null) {						message = "";					}					if (status >= 100 && status < 600) {						iq.setResult(status, message);					}					else {						throw new Exception("Invalid XMPP-REST result stanza");					}				}				else {					// Shouldn't happen					return null;				}			}			while (!done) {				int eventType = parser.next();				if (eventType == XmlPullParser.START_TAG) {					if (parser.getName().equals("headers")) {						parseHeaders(parser, iq);					}					else if (parser.getName().equals("body")) {						iq.setBody(unescapeXML(parser.nextText()));					}				}				else if (eventType == XmlPullParser.END_TAG) {					if ((iq.getRestType() == RestType.XMPPREST_QUERY && parser.getName().equals("query")) || 						(iq.getRestType() == RestType.XMPPREST_RESULT && parser.getName().equals("result"))){						done = true;					}				}			}			return iq;		}	}	public String getChildElementXML() {		StringBuilder buf = new StringBuilder();		buf.append("<");		switch(type) {		case XMPPREST_QUERY:			buf.append("query method=\"").append(escapeXML(method)).append("\" resource=\"").append(escapeXML(resource)).append("\"");			break;		case XMPPREST_RESULT:			buf.append("result status=\"").append(status).append("\" message=\"").append(escapeXML(message)).append("\"");			break;		default:			return "";		}		buf.append(" xmlns=\"").append(NAMESPACE).append("\">");		if (headers.size() > 0) {			buf.append("<headers>");			for(Map.Entry<String, String> e : headers.entrySet()) {				buf.append("<header field=\"").append(escapeXML(e.getKey())).append("\" value=\"").append(escapeXML(e.getValue())).append("\" />");			}			buf.append("</headers>");		}		if (body != null && body.length() > 0) {			buf.append("<body>").append(escapeXML(body)).append("</body>");		}		switch(type) {		case XMPPREST_QUERY:			buf.append("</query>");			break;		case XMPPREST_RESULT:			buf.append("</result>");			break;		}		return buf.toString();	}}